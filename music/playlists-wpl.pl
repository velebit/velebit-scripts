#!/usr/bin/perl
# Create Windows Media Player playlists from a MP3/M4A/... tree.
use warnings;
use strict;
use File::Find;
use Encode qw();
#use Cwd;

# allow Unicode (utf8-encoded) console output
BEGIN {
  binmode(STDOUT, ":utf8");
  binmode(STDERR, ":utf8");
};

my $script = $0;  $script =~ s,.*[/\\],,;

# Overwrite/remove existing playlists?
my $force = 1;
# Generate playlists in directories with only one MP3 file or subdirectory?
my $even_single = 1;

my @audio_exts = qw( mp3 m4a );
my $audio_exts_re = '\.(?i:' . join('|', map "\Q$_", @audio_exts) . ')';

# These functions convert from OS's raw byte representation of e.g. file names
# to Perl's Unicode strings, and back.  This probably just involves fixing the
# UTF8 flag on the string.
sub from_os ( $ ) { Encode::decode('utf8', $_[0]); }
sub to_os ( $ )   { Encode::encode('utf8', $_[0]); }

sub write_m3u8 ( $$@ ) {
  my ($file, $title, @list) = @_;
  open my $FILE, '>:utf8', $file or die "open(>$file): $!";
  print $FILE "\x{FEFF}";  # byte order mark, just to indicate this is Unicode
  print $FILE "## $title -- generated by $script\n";
  print $FILE "$_\n" for @list;
}

sub write_wpl ( $$@ ) {
  my ($file, $title, @list) = @_;
  my $count = scalar @list;
  my $text = <<"EndOfHeader";
<?wpl version="1.0"?>
<smil>
  <head>
    <meta name="Generator" content="$script"/>
    <meta name="ItemCount" content="$count"/>
    <title>$title</title>
  </head>
  <body><seq>
EndOfHeader
  for my $item (@list) {
    $item =~ s,/,\\,g;
    $item =~ s,&,&amp;,g;
    $text .= qq[    <media src="$item"/>\n];
  }
  $text .= <<"EndOfFooter";
  </seq></body>
</smil>
EndOfFooter
  $text =~ s/\r?//g;  $text =~ s/\n/\r\n/g;
  open my $FILE, '>:utf8', $file or die "open(>$file): $!";
  print $FILE $text;
}

my (%files_deep, %files_here, %children, %files_exts);
sub process_files {
  my $base = from_os $File::Find::name;
  $base =~ s/($audio_exts_re)$// or return;
  my $ext  = $1;
  -f $_    or return;  # don't use to_os(), $_ is native octets already

  my @dir = split m:/:, $base;
  my @file = pop @dir;

  if (exists $files_exts{join '/', @dir, @file}) {
    # A file with the same name but a different extension was already found.
    $files_exts{join '/', @dir, @file}{$ext}++;
    return;
  }

  while (@dir) {
    my $dir  = join '/', @dir;
    my $file = join '/', @file;
    push @{$files_deep{$dir}}, $file;
    push @{$files_here{$dir}}, $file if @file == 1;
    $children{$dir}{$file[0]}++;
    $files_exts{join '/', @dir, @file}{$ext}++;
    $dir[-1] eq 'christmas' and last;
    $dir[-1] eq 'classical' and last;
    $dir[-1] eq 'kids'      and last;
    unshift @file, pop @dir;
  }
}
sub base_with_ext ( $$ ) {
  my ($dir, $base) = @_;
  exists $files_exts{"$dir/$base"}
    or die "full name not known for '$dir'/'$base'";
  my $ext_hash = $files_exts{"$dir/$base"};
  # find the first entry in @audio_exts that matches
  for my $e (@audio_exts) {
    exists $ext_hash->{".$e"} and return "$base.$e";
  }
  die "extensions not matched for '$dir'/'$base' (@{[keys %$ext_hash]})";
}

find +{ preprocess => sub { sort @_; }, wanted => \&process_files }, '.';

for my $dir (sort keys %files_deep) {
  my $wpl  = "$dir/00_playlist.wpl";
  my $m3u8 = "$dir/00_playlist.m3u";  # gmusicbrowser wants Unicode M3U files

  # A playlist is expected only if
  # - $even_single is true and there are some MP3s or subdirs here, OR
  # - $even_single is false and there are at least 2 MP3s or subdirs here
  my $count = ( ($files_here{$dir} ? @{$files_here{$dir}} : 0) +
		($children{$dir} ? keys %{$children{$dir}} : 0) );
  my $limit = ($even_single ? 1 : 2);

  if ($count < $limit) {
    if (! -e $wpl && ! -e $m3u8) {
      print "SKIP  $dir\n";
    } elsif (!$force) {
      print "LEAVE $dir\n";
    } else {
      if (-e $wpl) {
	print "rm    $wpl\n";
	unlink $wpl or warn "unlink($wpl): $!";
      }
      if (-e $m3u8) {
	print "rm    $m3u8\n";
	unlink $m3u8 or warn "unlink($m3u8): $!";
      }
    }
    next;
  }

  if (! -e $wpl || ! -e $m3u8 || $force) {
    my $write_wpl  = ! -e $wpl  || $force;
    my $write_m3u8 = ! -e $m3u8 || $force;
    print "write $dir\n"  if $write_wpl && $write_m3u8;
    print "write $wpl\n"  if $write_wpl && ! $write_m3u8;
    print "write $m3u8\n" if $write_m3u8 && ! $write_wpl;
    die                   if ! $write_wpl && ! $write_m3u8;
    my $name = $dir;  $name =~ s,^.*/,,;
    my @files = map base_with_ext($dir, $_), @{$files_deep{$dir}};
    write_wpl  $wpl,  $name, @files if $write_wpl;
    write_m3u8 $m3u8, $name, @files if $write_m3u8;
  } else {
    print "KEEP  $dir\n";
  }
}
