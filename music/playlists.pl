#!/usr/bin/perl
# Create Windows Media Player (wpl) and m3u playlists from a MP3/M4A/... tree.
use warnings;
use strict;
use File::Find;
use Encode qw();
use Unicode::Collate;

# allow Unicode (utf8-encoded) console output
BEGIN {
  binmode(STDOUT, ":utf8");
  binmode(STDERR, ":utf8");
};

my $SCRIPT = $0;  $SCRIPT =~ s,.*[/\\],,;

# Which extension types are being written?
my ($default_wpl, $default_m3u, $default_m3u8, $default_qm3u) = (1, 1, 0, 0);
my $force_defaults = 0;
# Overwrite/remove existing playlists?
my $force_update = 1;
my $force_rm = 1;
# Generate playlists in directories with only one MP3 file or subdirectory?
my $even_single = 0;

my $playlist_base_name = '00_playlist';

my @audio_exts = qw( mp3 m4a flac );
my $audio_exts_re = '\.(?i:' . join('|', map "\Q$_", @audio_exts) . ')';

my $playlist_ext_wpl  = 'wpl';
my $playlist_ext_m3u  = 'm3u';
my $playlist_ext_m3u8 = 'm3u8';
my $playlist_ext_qm3u = 'quoted.m3u';

my $collator = Unicode::Collate->new();

# These functions convert from OS's raw byte representation of e.g. file names
# to Perl's Unicode strings, and back.  This probably just involves fixing the
# UTF8 flag on the string.
sub from_os ( $ ) { Encode::decode('utf8', $_[0]); }
sub to_os ( $ )   { Encode::encode('utf8', $_[0]); }

sub file_exists ( $ ) {
  my ($path) = @_;
  return -e to_os $path;
}

sub remove_file ( $ ) {
  my ($path) = @_;
  if (! unlink to_os $path) {
    warn "unlink($path): $!";
    return undef;
  }
  return 'rm';
}

sub write_file ( $$ ) {
  my ($path, $content) = @_;
  open my $FILE, '>:utf8', to_os $path
    or warn("open(>$path): $!"), return 'FAIL';
  print $FILE $content
    or warn("print(>$path): $!"), return 'FAIL';
  return 'write';
}

sub read_file ( $ ) {
  my ($path) = @_;
  open my $FILE, '<:utf8', to_os $path
    or return undef;  # This is NOT an error!
  local ($/) = undef;  # slurp
  return scalar <$FILE>;
}

sub write_if_changed ( $$ ) {
  my ($path, $content) = @_;
  my $old_content = read_file $path;
  if (defined $old_content and $old_content eq $content) {
    return 'same';  # don't bother overwriting
  }
  return write_file $path, $content;
}

sub uri_strict_encode_characters ( $ ) {
  my ($text) = @_;
  $text = Encode::encode('utf8', $text);
  $text =~ s@([^-._~A-Za-z0-9/])@sprintf "%%%02x", ord($1)@ge;
  $text;
}

sub uri_encode_characters ( $ ) {
  my ($text) = @_;
  $text = Encode::encode('utf8', $text);
  $text =~ s@([^-._~A-Za-z0-9/ ()'!])@sprintf "%%%02x", ord($1)@ge;
  $text;
}

sub write_m3u_variant ( $$$@ ) {
  my ($file, $cfg, $title, @list) = @_;
  my $content = '';
  $cfg->{utf8_bom}
    and $content .= "\x{FEFF}";  # byte order mark, to indicate this is Unicode
  $content .= "## $title -- generated by $SCRIPT\n";
  $cfg->{quote_uri_strict}
    and @list = map uri_strict_encode_characters($_), @list;
  $cfg->{quote_uri}
    and @list = map uri_encode_characters($_), @list;
  $content .= "$_\n" for @list;
  return write_if_changed $file, $content;
}

sub write_m3u_utf8 ( $$@ ) {
  # gmusicbrowser expects Unicode .m3u files with a BOM
  my ($file, $title, @list) = @_;
  write_m3u_variant $file, { utf8_bom => 1, quote_uri => 0 }, $title, @list;
}

sub write_m3u8 ( $$@ ) {
  my ($file, $title, @list) = @_;
  write_m3u_variant $file, { utf8_bom => 0, quote_uri => 0 }, $title, @list;
}

sub write_quoted_m3u ( $$@ ) {
  # VLC expects .m3u files to be URL-encoded
  my ($file, $title, @list) = @_;
  write_m3u_variant $file, { utf8_bom => 0, quote_uri => 1 }, $title, @list;
}

sub encode_wpl_characters ( $ ) {
  my ($text) = @_;
  $text =~ s,&,&amp;,g;
  $text =~ s,",&quot;,g;
  $text =~ s,<,&lt;,g;
  $text =~ s,>,&gt;,g;
  $text;
}

sub write_wpl ( $$@ ) {
  my ($file, $title, @list) = @_;
  my $count = scalar @list;
  $title = encode_wpl_characters $title;
  my $text = <<"EndOfHeader";
<?wpl version="1.0"?>
<smil>
  <head>
    <meta name="Generator" content="$SCRIPT"/>
    <meta name="ItemCount" content="$count"/>
    <title>$title</title>
  </head>
  <body><seq>
EndOfHeader
  for my $item (@list) {
    $item =~ s,/,\\,g;
    $item = encode_wpl_characters $item;
    $text .= qq[    <media src="$item"/>\n];
  }
  $text .= <<"EndOfFooter";
  </seq></body>
</smil>
EndOfFooter
  $text =~ s/\r?//g;  $text =~ s/\n/\r\n/g;
  return write_if_changed $file, $text;
}

sub get_suffix ( $$ ) {
  my ($text, $base) = @_;
  $text =~ s/^\Q$base// or die "'$text' does not start with '$base'";
  return $text;

}

my (%playlists_found, %playlists_global_exts);

sub process_playlist_file ( $$$ ) {
  my ($dir, $file_base, $ext) = @_;
  $playlists_found{$dir}{"$file_base$ext"}++;
  $playlists_global_exts{$ext}++;
}

my (%files_deep, %files_here, %children, %files_exts);

sub process_audio_file ( $$$ ) {
  my ($dir, $file_base, $ext) = @_;

  if (exists $files_exts{"$dir/$file_base"}) {
    # A file with the same name but a different extension was already found.
    $files_exts{"$dir/$file_base"}{$ext}++;
    return;
  }

  $files_exts{"$dir/$file_base"}{$ext}++;
  $files_here{$dir}{$file_base}++;

  my @dir = split m:/:, $dir;
  my @file = ($file_base);

  while (@dir) {
    my $jdir  = join '/', @dir;
    my $jfile = join '/', @file;
    $files_deep{$jdir}{$jfile}++;
    $children{$jdir}{$file[0]}++ if @file >= 2;
    $dir[-1] eq 'christmas' and last;
    $dir[-1] eq 'classical' and last;
    $dir[-1] eq 'from_SanDisk_player' and last;
    $dir[-1] eq 'kids' and last;
    $dir[-1] eq 'musical' and last;
    unshift @file, pop @dir;
  }
}

sub base_with_ext ( $$ ) {
  my ($dir, $base) = @_;
  exists $files_exts{"$dir/$base"}
    or die "full name not known for '$dir'/'$base'";
  my $ext_hash = $files_exts{"$dir/$base"};
  # find the first entry in @audio_exts that matches
  for my $e (@audio_exts) {
    exists $ext_hash->{".$e"} and return "$base.$e";
  }
  die "extensions not matched for '$dir'/'$base' (@{[keys %$ext_hash]})";
}

sub preprocess_files {
  return map to_os($_), $collator->sort(map from_os($_), @_);
}

sub process_files {
  # Only process files. Don't use to_os(), $_ is native octets already.
  return unless -f $_;

  my $path = from_os $File::Find::name;
  if ($path =~ s,/+($playlist_base_name)(\.[^/]+)$,,) {
    process_playlist_file $path, $1, $2;
    return;
  }
  if ($path =~ s,/+([^/]+)($audio_exts_re)$,,) {
    process_audio_file $path, $1, $2;
    return;
  }
}

find +{ preprocess => \&preprocess_files, wanted => \&process_files }, '.';

# determine what to write based on what files are already present
my ($write_wpl, $write_m3u, $write_m3u8, $write_qm3u) = (0, 0, 0, 0);
if (! $force_defaults) {
  $write_wpl  = 1 if exists $playlists_global_exts{".$playlist_ext_wpl"};
  $write_m3u  = 1 if exists $playlists_global_exts{".$playlist_ext_m3u"};
  $write_m3u8 = 1 if exists $playlists_global_exts{".$playlist_ext_m3u8"};
  $write_qm3u = 1 if exists $playlists_global_exts{".$playlist_ext_qm3u"};
}
if (! ($write_wpl || $write_m3u || $write_m3u8 || $write_qm3u)) {
  ($write_wpl, $write_m3u, $write_m3u8, $write_qm3u) =
    ($default_wpl, $default_m3u, $default_m3u8, $default_qm3u);
}

my @active_dirs;
{
  my %active_dirs = map +($_ => 1), keys(%files_deep), keys(%playlists_found);
  @active_dirs = $collator->sort(keys %active_dirs);
}

for my $dir (@active_dirs) {
  # A playlist is expected only if
  # - $even_single is true and there are some MP3s or subdirs here, OR
  # - $even_single is false and there are at least 2 MP3s or subdirs here
  my $count = ( ($files_here{$dir} ? keys %{$files_here{$dir}} : 0) +
		($children{$dir} ? keys %{$children{$dir}} : 0) );
  my $limit = ($even_single ? 1 : 2);

  my ($need_wpl, $need_m3u, $need_m3u8, $need_qm3u) =
    ($write_wpl, $write_m3u, $write_m3u8, $write_qm3u);
  ($count < $limit)
    and ($need_wpl, $need_m3u, $need_m3u8, $need_qm3u) = (0, 0, 0, 0);

  my (%result_for_ext);

  my $name = $dir;  $name =~ s,^.*/,,;
  my @files = map base_with_ext($dir, $_),
    $collator->sort(keys %{$files_deep{$dir}});

  if ($need_wpl) {
    my $ext = $playlist_ext_wpl;
    my $wpl = "$playlist_base_name.$ext";
    if ($force_update or ! file_exists "$dir/$wpl") {
      my $result = write_wpl "$dir/$wpl", $name, @files;
      $result and push @{$result_for_ext{$result}}, $ext;
    } else {
      push @{$result_for_ext{'keep'}}, $ext;
    }
    delete $playlists_found{$dir}{$wpl};
  }
  if ($need_m3u) {
    my $ext = $playlist_ext_m3u;
    my $m3u = "$playlist_base_name.$ext";
    if ($force_update or ! file_exists "$dir/$m3u") {
      my $result = write_m3u_utf8 "$dir/$m3u", $name, @files;
      $result and push @{$result_for_ext{$result}}, $ext;
    } else {
      push @{$result_for_ext{'keep'}}, $ext;
    }
    delete $playlists_found{$dir}{$m3u};
  }
  if ($need_m3u8) {
    my $ext = $playlist_ext_m3u8;
    my $m3u8 = "$playlist_base_name.$ext";
    if ($force_update or ! file_exists "$dir/$m3u8") {
      my $result = write_m3u8 "$dir/$m3u8", $name, @files;
      $result and push @{$result_for_ext{$result}}, $ext;
    } else {
      push @{$result_for_ext{'keep'}}, $ext;
    }
    delete $playlists_found{$dir}{$m3u8};
  }
  if ($need_qm3u) {
    my $ext = $playlist_ext_qm3u;
    my $qm3u = "$playlist_base_name.$ext";
    if ($force_update or ! file_exists "$dir/$qm3u") {
      my $result = write_quoted_m3u "$dir/$qm3u", $name, @files;
      $result and push @{$result_for_ext{$result}}, $ext;
    } else {
      push @{$result_for_ext{'keep'}}, $ext;
    }
    delete $playlists_found{$dir}{$qm3u};
  }

  for my $playlist ($collator->sort(keys %{$playlists_found{$dir}})) {
    my $ext = get_suffix $playlist, "$playlist_base_name.";
    if ($force_rm) {
      my $result = remove_file "$dir/$playlist";
      $result and push @{$result_for_ext{$result}}, $ext;
    } else {
      push @{$result_for_ext{'leave'}}, $ext;
    }
  }

  for my $r (sort keys %result_for_ext) {
    if (@{$result_for_ext{$r}} == 1) {
      printf "%-5s %s\n", $r, ($dir . '/' . $playlist_base_name . '.'
                               . $result_for_ext{$r}[0]);
    } elsif (@{$result_for_ext{$r}}) {
      printf "%-5s %s\n", $r, ($dir . '/' . $playlist_base_name . '.{'
                               . join(',', @{$result_for_ext{$r}}) . '}');
    }
  }

  if (! %result_for_ext) {
    printf "%-5s %s\n", "N/A", $dir;
  }
}
