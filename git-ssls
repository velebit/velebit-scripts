#!/usr/bin/perl
use warnings;
use strict;

{
  package WorkingDirectory;
  use Carp;
  use Cwd ();

  sub new ( $$ ) {
    my ($class, $new_dir) = @_;
    $class = ref $class if ref $class;
    return bless {}, $class if ! defined $new_dir;

    my $old_dir = Cwd::getcwd
      or croak "Could not determine old working directory";
    chdir $new_dir
      or croak "chdir($new_dir): $!";

    return bless { old => $old_dir, new => $new_dir }, $class;
  }

  sub DESTROY ( $ ) {
    my ($obj) = @_;
    !exists $obj->{old}
      or chdir $obj->{old}
      or croak "chdir($obj->old): $!";
  }
  1;
}

sub remove_ansi ( $ ) {
  local ($_) = @_;
  s/\e\[\d{1,2}(?:;\d{1,2})?m//g;  # remove ANSI color sequences
  s/\e\[K//g;  # remove ANSI "Erase in Line" sequences
  $_;
}

use constant EXPAND_SUBMODULES => 1;

my %status;

sub process_status ( ;$ );
sub process_status ( ;$ ) {
  my ($dir) = @_;

  my $prefix = (defined $dir ? "$dir/" : '');
  $prefix =~ s,//+$,/,;
  my $temp_wd = WorkingDirectory->new($dir) if defined $dir;

  open(my $STATUS, '-|', qw( git -c color.status=always status -sb ))
    or die "open(git status|): $!";

  while (<$STATUS>) {
    my ($stat, $path) = /(^.{10,18}? )([^\e]*)\r?\n/
      or ($prefix or print), next;
    # if working in a prefix subdirectory, ignore paths back out of that subdir
    $prefix and $path =~ m,^\.\./, and next;

    # normalize path
    $path =~ s,.* -> ,,;
    $path = $prefix . $path;
    $path =~ s,/+\.(/*)$,$1, if $prefix;

    if (! -d $path or ! EXPAND_SUBMODULES or $path eq $prefix) {
      $status{$path} = $stat;
    } else {
      # a subdirectory may or may not be a submodule, but this works for both
      process_status $path;
    }
  }
}

process_status;

my $NUM_INITIAL_FIELDS;
{
  open(my $LS_DOT, '-|', 'ls', '-ldrt', '.')
    or die "open(ls .|): $!";
  $NUM_INITIAL_FIELDS = scalar(split /\s+/, scalar <$LS_DOT>) - 1;
}

sub get_filename ( $ ) {
  local ($_) = @_;
  s/\r?\n$//;
  s/^(?:\S+\s+){$NUM_INITIAL_FIELDS}//;
  s/ -> .*//;  # handle symlinks
  remove_ansi $_;
}

if (keys %status) {
  open(my $LS, '-|', ('ls', '-ldrt', '--quoting-style=literal',
                      '--color=always',
                      keys %status))
    or die "open(ls -ldrt|): $!";
  while (<$LS>) {
    my $name = get_filename $_;
    warn "No status for '@{[join '', map sprintf('[%02x]', ord $_), split //, $name]}'" unless exists $status{$name};
    s/^/$status{$name}/, delete $status{$name} if exists $status{$name};
    print;
  }
}

for my $name (sort keys %status) {
  warn "No file for '@{[join '', map sprintf('[%02x]', ord $_), split //, $name]}' ($name)";
  print $status{$name} . $name . "\n";
}
