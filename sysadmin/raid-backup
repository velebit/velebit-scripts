#!/bin/sh

fail () {
    if [ "$#" -eq 0 ]; then set -- "Something has gone very wrong!"; fi
    echo "$*" >&2
    exit 1
}

status () {
    echo "-- [`date +'%Y-%m-%d %H:%M:%S'`] -- $*"
}

backup=/backup
full_backup="home"
tar_backup="scratch root boot"

dryrun=

while [ "$#" -gt 0 ]; do
    case "$1" in
       -n)  dryrun=yes ;;
       -*)  fail "Unknown flag '$1'" ;;
        *)  fail "Unexpected argument '$1'" ;;
    esac
    shift
done

[ -n "`mount | awk '($3 == "'"$backup"'")'`" ] \
    || fail "$backup isn't mounted!"

Run () {
    if [ -n "$dryrun" ]; then
	echo "WOULD run:      $*" >&2
    else
	echo "# $*" >&2  # NB: this does go to the log file
	"$@"
    fi
}
TimeRun () {
    if [ -n "$dryrun" ]; then
	echo "WOULD run: time $*" >&2
    else
	echo "# time $*" >&2  # NB: this does go to the log file
	time "$@"
    fi
}

TestBad () {
    if [ -n "$dryrun" ]; then false;  else test "$@";  fi
}
TestGood () {
    if [ -n "$dryrun" ]; then true;   else test "$@";  fi
}

CheckSpace () {
    echo "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    df -h "$backup"
    echo "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
}
disk_used_kb () {
    df -k "$backup" | awk '($1~/^\/dev\//){print $3}'
}
disk_free_kb () {
    # NB: we don't use df's "free" number ($4), since that number is
    #   calibrated to hit zero when you get to 95% disk usage (100%
    #   minus the "reserved" 5%!)
    df -k "$backup" | awk '($1~/^\/dev\//){printf "%d",$2-$3}'
}

#units_to_bytes () {
#    awk '{for(i=1;i<=NF;++i){a=$i;if(a~/T$/){a=a*1024 "G"};if(a~/G$/){a=a*1024 "M"};if(a~/M$/){a=a*1024 "K"};if(a~/K$/){a=a*1024};printf "%s%.0f",((i>1)?" ":""),a};printf "\n"}'
#}
#bytes_to_units () {
#    awk '{for(i=1;i<=NF;++i){a=$i;s=1;u="";if(a<0){a=-a;s=-1};if(a>1024){a/=1024;u="K";if(a>1024){a/=1024;u="M";if(a>1024){a/=1024;u="G";if(a>1024){a/=1024;u="T"}}}};printf "%s%.1f%s",((i>1)?" ":""),s*a,u};printf "\n"}'
#}
kb_to_units () {
    awk '{for(i=1;i<=NF;++i){a=$i;s=1;u="K";if(a<0){a=-a;s=-1};if(a>1024){a/=1024;u="M";if(a>1024){a/=1024;u="G";if(a>1024){a/=1024;u="T"}}};printf "%s%.1f%s",((i>1)?" ":""),s*a,u};printf "\n"}'
}

max_backup_size=0
min_disk_free="`disk_free_kb`"

run_backup () {
    local src="$1"
    local dst_base="$2"
    local dst_ext="$3"
    local dst="$dst_base$dst_ext"

    set --
    for ext in '' '.tar.gz' '.tar.bz2'; do
	local xdst="$dst_base$ext"
	if [ -e "$xdst.old" -a -e "$xdst" ]; then
	    status "Cleaning up previous $xdst..."
	    Run rm -rf "$xdst.old" || fail "couldn't remove $xdst.old"
	    TestBad -e "$xdst.old" && fail "didn't actually remove $xdst.old"
	    status "...done."
	    CheckSpace
	fi
	if [ -e "$xdst" ]; then
	    set -- "$@" "$xdst"
	    Run mv "$xdst" "$xdst.old" || fail "couldn't move old $xdst"
	fi
    done

    local free_before="`disk_free_kb`"

    status "Backing up $src to $dst..."
    case "$dst" in
	*.tar.gz)
	    TimeRun tar -C "$src" --one-file-system -czf "$dst" . \
		|| fail "The tarballing went kaboom."
	    ;;
	*.tar.bz2)
	    TimeRun tar -C "$src" --one-file-system -cjf "$dst" . \
		|| fail "The tarballing went kaboom."
	    ;;
	*)
	    Run mkdir -p "$dst" || fail "couldn't create new directory $dst"
	    (TimeRun tar -C "$src" --one-file-system -cf - . \
		| Run tar -C "$dst" -xpf -) || fail "The copying went kaboom."
	    ;;
    esac
    status "...done."
    CheckSpace

    local free_after="`disk_free_kb`"
    local space_used="`expr "$free_before" - "$free_after"`"
    if [ "$min_disk_free" -gt "$free_after" ]; then
	min_disk_free="$free_after"
    fi
    if [ "$max_backup_size" -lt "$space_used" ]; then
	max_backup_size="$space_used"
    fi
 
    for xdst in "$@"; do
	status "Cleaning up previous $xdst..."
	Run rm -rf "$xdst.old"
	status "...done."
	CheckSpace
    done
}

partition_path () {
    if [ "$1" = "root" ]; then echo "/"; else echo "/$1"; fi
}
backup_path () {
    echo "$backup/$1"
}

run_all_backups () {
    CheckSpace

    for i in $full_backup; do
	run_backup "`partition_path $i`" "`backup_path $i`" ""
    done

    for i in $tar_backup; do
	run_backup "`partition_path $i`" "`backup_path $i`" ".tar.bz2"
    done

    status "Min. observed disk margin:  `echo "$min_disk_free" | kb_to_units`"
    if [ -z "$dryrun" ]; then
	local free="`disk_free_kb`"
	local margin="`expr "$free" - "$max_backup_size"`"
	status "Min. projected disk margin: `echo "$margin" | kb_to_units`"
    fi
}

if [ -t 1 ]; then
    # Only create a log file if the output is being sent to a terminal,
    # and if this isn't a dry run.
    log="$backup/log.`date +'%Y-%m-%d'`.txt"
    if [ -e "$log" ]; then
	log="$backup/log.`date +'%Y-%m-%d.%H-%M'`.txt"
	if [ -e "$log" ]; then
	    for x in a b c d e f g h i j k l m n o p q r s t u v w x y z; do
		log="$backup/log.`date +'%Y-%m-%d.%H-%M'`.$x.txt"
		if [ ! -e "$log" ]; then break; fi
	    done
	fi
    fi
    if [ -z "$dryrun" ]; then
	status "Will write log to $log"
	run_all_backups 2>&1 | tee "$log"
    else
	status "Would write log to $log"
	run_all_backups
    fi
else
    run_all_backups
fi
