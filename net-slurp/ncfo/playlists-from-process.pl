#!/usr/bin/perl
#
# usage: playlists-from-process [-p PREFIX] [-s SUFFIX]
#
# Reads processing directives on stdin, and outputs the same
# directives on stdout.  Also extracts the lists of files from the
# directives and produces playlists for them.
use warnings;
use strict;
use Encode qw();
use Getopt::Long;

# allow Unicode (utf8-encoded) console output
BEGIN {
  binmode(STDOUT, ":utf8");
  binmode(STDERR, ":utf8");
};

my $script = $0;  $script =~ s,.*[/\\],,;

my ($PREFIX, $SUFFIX);

GetOptions('prefix|p=s' => \$PREFIX,
	   'suffix|s=s' => \$SUFFIX,
          ) or die "Usage: $script [-p PREFIX] [-s SUFFIX] [FILES...]\n";

if (! defined $PREFIX) {
  $PREFIX = `./canonicalize-filenames.pl --print-short`;
  $PREFIX =~ s/\s+/ /sg;
  $PREFIX =~ s/\s*$/ /;
  $PREFIX =~ s/^\s+//;
}
$SUFFIX = ' practice' if ! defined $SUFFIX;

# These functions convert from OS's raw byte representation of e.g. file names
# to Perl's Unicode strings, and back.  This probably just involves fixing the
# UTF8 flag on the string.
sub from_os ( $ ) { Encode::decode('utf8', $_[0]); }
sub to_os ( $ )   { Encode::encode('utf8', $_[0]); }

sub write_m3u8 ( $$@ ) {
  my ($file, $title, @list) = @_;
  open my $FILE, '>:utf8', $file or die "open(>$file): $!";
  #print $FILE "\x{FEFF}";  # byte order mark, just to indicate this is Unicode
  print $FILE "## $title -- generated by $script\n";
  print $FILE "$_\n" for @list;
}

sub encode_wpl_characters ( $ ) {
  my ($text) = @_;
  $text =~ s,&,&amp;,g;
  $text =~ s,",&quot;,g;
  $text =~ s,<,&lt;,g;
  $text =~ s,>,&gt;,g;
  $text;
}

sub write_wpl ( $$@ ) {
  my ($file, $title, @list) = @_;
  my $count = scalar @list;
  $title = encode_wpl_characters $title;
  my $text = <<"EndOfHeader";
<?wpl version="1.0"?>
<smil>
  <head>
    <meta name="Generator" content="$script"/>
    <meta name="ItemCount" content="$count"/>
    <title>$title</title>
  </head>
  <body><seq>
EndOfHeader
  for my $item (@list) {
    $item =~ s,/,\\,g;
    $item = encode_wpl_characters $item;
    $text .= qq[    <media src="$item"/>\n];
  }
  $text .= <<"EndOfFooter";
  </seq></body>
</smil>
EndOfFooter
  $text =~ s/\r?//g;  $text =~ s/\n/\r\n/g;
  open my $FILE, '>:utf8', $file or die "open(>$file): $!";
  print $FILE $text;
}


my %lists;

while (<>) {
  print;

  s/\r?\n$//;
  my $path = ((split /=/, $_, 2)[1]);
  my ($dir_path, $file) = ($path =~ m,^(.+)/([^/]+)$,);
  defined $dir_path or warn("No directory found in '$path'"), next;

  1 while $dir_path =~ s,^\./,,;
  1 while $dir_path =~ s,/\./,/,;
  $dir_path =~ s,//+,/,g;
  push @{$lists{$dir_path}}, $file;
}

for my $dir_path (sort keys %lists) {
  my ($top_path, $dir) = ($dir_path =~ m,^(.*/)([^/]+)$,);
  defined $top_path or ($top_path, $dir) = ('./', $dir_path);

  my $base_name = $PREFIX . $dir . $SUFFIX;
  my @files = map "$dir/$_", @{$lists{$dir_path}};

  write_m3u8 "$top_path$base_name.m3u", $base_name, @files;
  write_wpl "$top_path$base_name.wpl", $base_name, @files;
  print STDERR "Generated $base_name.m3u and $base_name.wpl\n";
}
